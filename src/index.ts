import {
  app,
  net,
  BrowserWindow,
  autoUpdater,
  ipcMain,
  shell,
  dialog,
  powerMonitor,
} from 'electron'
import path from 'path'
import url from 'url'
import log from 'electron-log'
import installExtension, { REACT_DEVELOPER_TOOLS } from 'electron-devtools-installer'
import { getLastUser, getAppBounds, setAppBounds, sqliteEvents } from './services/sqlite'
import { capture } from './services/analytics'
import { isDev, isTesting, logger } from './utils'
import { serializeError, deserializeError } from 'serialize-error'
import type { Tag, EntryTag } from 'types'

require('./services/mdx')
require('./services/saveFile')

var openUrl = ''

if (process.defaultApp) {
  if (process.argv.length >= 2) {
    app.setAsDefaultProtocolClient('journal', process.execPath, [path.resolve(process.argv[1])])
  }
} else {
  app.setAsDefaultProtocolClient('journal')
}

// This allows TypeScript to pick up the magic constant that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string

// Env
// process.env.NODE_ENV = 'development'

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  // eslint-disable-line global-require
  app.quit()
}

const createWindow = (): void => {
  // Create the browser window.
  const bounds = getAppBounds(1200, 800)
  const mainWindow = new BrowserWindow({
    ...bounds,
    minWidth: 400,
    minHeight: 300,
    titleBarStyle: 'customButtonsOnHover',
    trafficLightPosition: { x: 16, y: 16 },
    show: false,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      nodeIntegration: false,
      sandbox: true,
      spellcheck: true,
    },
  })

  ipcMain.on('electron-reload', async () => {
    mainWindow.reload()
  })

  mainWindow.on('resized', () => {
    logger('resized')
    setAppBounds(mainWindow.getBounds())
    capture({
      distinctId: getLastUser(),
      event: 'app resized',
      properties: mainWindow.getBounds(),
    })
  })

  mainWindow.on('moved', () => {
    logger('moved')
    setAppBounds(mainWindow.getBounds())
  })

  mainWindow.on('maximize', () => {
    logger('maximize')
    capture({
      distinctId: getLastUser(),
      event: 'app maximize',
    })
  })

  mainWindow.on('minimize', () => {
    logger('minimize')
    capture({
      distinctId: getLastUser(),
      event: 'app minimize',
    })
  })

  mainWindow.on('enter-full-screen', () => {
    logger('enter-full-screen')
    capture({
      distinctId: getLastUser(),
      event: 'app enter-full-screen',
    })
  })

  // Session time
  var start: [number, number]
  var sessionActive = false
  mainWindow.on('focus', () => {
    start = process.hrtime()
    sessionActive = true
    logger('Focus')
  })
  mainWindow.on('blur', () => {
    logger('Blur')
    let sessionTime = process.hrtime(start)[0]
    sessionActive = false
    logger(`Session: ${sessionTime} seconds`)
    capture({
      distinctId: getLastUser(),
      event: 'session',
      properties: { sessionTime },
    })
  })

  mainWindow.on('close', () => {
    logger('Close')
    capture({
      distinctId: getLastUser(),
      event: 'app window close',
    })
    if (sessionActive) {
      let sessionTime = process.hrtime(start)[0]
      logger(`Session: ${sessionTime} seconds`)
      capture({
        distinctId: getLastUser(),
        event: 'session',
        properties: { sessionTime },
      })
    }
  })

  mainWindow.once('ready-to-show', () => {
    mainWindow.show()

    capture({
      distinctId: getLastUser(),
      event: 'app launched',
    })

    // Handle open from url when app was closed
    if (openUrl) {
      mainWindow.webContents.send('open-url', openUrl)
      capture({
        distinctId: getLastUser(),
        event: 'app open-from-url',
      })
      openUrl = ''
    }
  })

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY)

  // Open the DevTools.
  if (isDev() && !isTesting()) {
    mainWindow.webContents.openDevTools()
    installExtension(REACT_DEVELOPER_TOOLS)
      .then((name) => console.log(`Added Extension:  ${name}`))
      .catch((err) => console.log('An error occurred: ', err))
  }

  ipcMain.removeHandler('electron-disableSpellCheck')
  ipcMain.handle('electron-disableSpellCheck', async () => {
    logger('electron-disableSpellCheck')
    mainWindow.webContents.session.setSpellCheckerLanguages([])
  })

  ipcMain.removeHandler('electron-enableSpellCheck')
  ipcMain.handle('electron-enableSpellCheck', async () => {
    logger('electron-enableSpellCheck')
    mainWindow.webContents.session.setSpellCheckerLanguages(
      mainWindow.webContents.session.availableSpellCheckerLanguages
    )
  })

  mainWindow.webContents.on('context-menu', (event: any, params: any) => {
    logger('context-menu event')

    mainWindow.webContents.send('electron-handleSpellCheck', params)
    // const menu = new Menu()

    // // Add each spelling suggestion
    // for (const suggestion of params.dictionarySuggestions) {
    //   menu.append(
    //     new MenuItem({
    //       label: suggestion,
    //       click: () => mainWindow.webContents.replaceMisspelling(suggestion),
    //     })
    //   )
    // }

    // // Allow users to add the misspelled word to the dictionary
    // if (params.misspelledWord) {
    //   menu.append(
    //     new MenuItem({
    //       label: 'Add to dictionary',
    //       click: () =>
    //         mainWindow.webContents.session.addWordToSpellCheckerDictionary(params.misspelledWord),
    //     })
    //   )
    // }

    // menu.popup()
  })
}

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', createWindow)

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  app.quit()
})

app.on('before-quit', () => {
  logger('before-quit')
  capture({
    distinctId: getLastUser(),
    event: 'app close',
  })
})

app.on('before-quit', () => {
  logger('quit')
})

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow()
  }
})

// Handle the protocol
app.on('open-url', (event, url) => {
  const win = BrowserWindow.getAllWindows()[0]
  if (win) {
    // Handle open from url when app is opened
    win.webContents.send('open-url', url)
  } else {
    // If app is closed/no windows, save url for when app opens
    openUrl = url
  }
})

// Open links in the browser
app.on('web-contents-created', (event, contents) => {
  contents.on('will-navigate', (event, navigationUrl) => {
    const parsedUrl = new url.URL(navigationUrl)
    const isDev = parsedUrl.host == 'localhost:3000'
    if (!isDev && ['https:', 'http:', 'mailto:'].includes(parsedUrl.protocol)) {
      event.preventDefault()
      shell.openExternal(navigationUrl)
    }
  })
  contents.setWindowOpenHandler(({ url }) => {
    return { action: 'deny' }
  })
})

// app.commandLine.appendSwitch('ignore-certificate-errors')

process.on('uncaughtException', (error) => {
  logger('uncaughtException')
  logger(error)
  log.error(error)
  if (!isDev()) {
    capture({
      type: 'error',
      distinctId: getLastUser(),
      event: 'error uncaughtException',
      properties: serializeError(error),
    })
  }
})

ipcMain.on('is-testing', function (event) {
  event.returnValue = process.argv.includes('testing')
})

ipcMain.on('power-monitor-idle-state', function (event) {
  event.returnValue = powerMonitor.getSystemIdleState(100)
})

ipcMain.on('net-is-online', function (event) {
  event.returnValue = net.isOnline()
})

// Time simulation in testing only
if (process.argv.includes('testing')) {
  ipcMain.on('test-set-date', function (date) {
    const win = BrowserWindow.getAllWindows()[0]
    win.webContents.send('test-set-date', date)

    // @ts-ignore Extend Date constructor to default to fakeNow
    Date = class extends Date {
      // @ts-ignore
      constructor(...args) {
        if (args.length === 0) {
          // @ts-ignore
          super(date)
        } else {
          // @ts-ignore
          super(...args)
        }
      }
    }
    // @ts-ignore Override Date.now() to start from fakeNow
    const __DateNowOffset = date - Date.now()
    const __DateNow = Date.now
    Date.now = () => __DateNow() + __DateNowOffset
  })
}

powerMonitor.on('resume', () => {
  logger('Resume from sleep')
  const win = BrowserWindow.getAllWindows()[0]
  win.webContents.send('power-monitor-resume')
})

// Handle events from SQLIte
sqliteEvents.on('sqlite-entry-event', () => {
  const win = BrowserWindow.getAllWindows()[0]
  win.webContents.send('sqlite-entry-event')
})
sqliteEvents.on('sqlite-tag-event', () => {
  const win = BrowserWindow.getAllWindows()[0]
  win.webContents.send('sqlite-tag-event')
})

// Handle Update downloaded
autoUpdater.on('update-downloaded', () => {
  logger('update-downloaded')
  log.info('update-downloaded')
  const win = BrowserWindow.getAllWindows()[0]
  if (win) win.webContents.send('update-downloaded')
})

// Handle errors
autoUpdater.on('error', (error: any) => {
  logger('Error:')
  logger(error)
  log.info('Error:')
  log.info(error)
  capture({
    type: 'error',
    distinctId: getLastUser(),
    event: 'error auto-updater',
    properties: serializeError(error),
  })
  if (error?.domain == 'SQRLUpdaterErrorDomain' && error?.code == 8) {
    logger('Read-only volume')
    log.info('Read-only volume')
    dialog.showMessageBoxSync({
      message:
        "You've launched Journal on a read-only volume. Please move Journal to Applications folder and try again.",
      title: 'read-only volume',
      type: 'warning',
    })
    app.quit()
  }
})

// Rest of autoUpdate logic
require('./services/autoUpdater')

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
